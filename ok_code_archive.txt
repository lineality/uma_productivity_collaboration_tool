
/// Read user confirmation with clean stdin buffer
///
/// # Purpose
///
/// Safely reads a yes/no confirmation from user by first clearing
/// any leftover input in the stdin buffer. This prevents the common
/// issue where previous operations leave characters in the buffer
/// that interfere with fresh prompts.
///
/// # Project Context
///
/// Interactive CLI applications often have stdin buffer pollution when
/// multiple input operations occur in sequence. This helper ensures
/// each confirmation prompt starts with a clean slate.
///
/// # Arguments
///
/// * `prompt` - The question/prompt to display to user
///
/// # Returns
///
/// * `Ok(true)` - User confirmed (answered 'y' or 'yes')
/// * `Ok(false)` - User declined (answered 'n' or 'no' or anything else)
/// * `Err(io::Error)` - I/O error reading from stdin
///
/// # Examples
///
/// ```rust
/// if read_user_confirmation("Proceed with deletion?")? {
///     delete_file()?;
/// } else {
///     println!("Cancelled");
/// }
/// ```
fn read_user_confirmation(prompt: &str) -> io::Result<bool> {
    // Clear stdin buffer first
    println!("\nPress ENTER to continue...");
    let mut _buffer_clear = String::new();
    io::stdin().read_line(&mut _buffer_clear)?;

    // Show prompt
    print!("{} (y/n): ", prompt);
    io::stdout().flush()?;

    // Read response
    let mut response = String::new();
    io::stdin().read_line(&mut response)?;    // Clear stdin buffer first
    println!("\nPress ENTER to continue...");
    let mut _buffer_clear = String::new();
    io::stdin().read_line(&mut _buffer_clear)?;
    let response = response.trim().to_lowercase();

    // Return true only for explicit yes
    Ok(response == "y" || response == "yes")
}


// alt
/// Searches for a node configuration file in the given directory.
///
/// This function looks for either `node.toml` or `node.gpgtoml` in the specified directory.
/// It checks for `node.toml` first, and if not found, checks for `node.gpgtoml`.
///
/// # Arguments
///
/// * `input_node_parent_path` - The directory path where to search for the node configuration files
///
/// # Returns
///
/// * `Some(PathBuf)` - The full path to the found configuration file (either node.toml or node.gpgtoml)
/// * `None` - Neither configuration file was found in the directory
///
/// # Example
///
/// ```
/// let parent_path = Path::new("/home/user/project");
/// if let Some(config_path) = find_node_toml_or_gpgtoml_file(parent_path) {
///     println!("Found configuration at: {:?}", config_path);
/// } else {
///     println!("No configuration file found");
/// }
/// ```
fn alt_find_node_toml_or_gpgtoml_file(input_node_parent_path: &Path) -> Option<PathBuf> {
    // First, try to find node.toml in the parent directory
    let node_toml = input_node_parent_path.join("node.toml");

    // Check if node.toml exists and is a regular file (not a directory)
    if node_toml.exists() && node_toml.is_file() {
        // Return the path to node.toml if found
        return Some(node_toml);
    }

    // If node.toml wasn't found, try to find node.gpgtoml
    let node_gpgtoml = input_node_parent_path.join("node.gpgtoml");

    // Check if node.gpgtoml exists and is a regular file (not a directory)
    if node_gpgtoml.exists() && node_gpgtoml.is_file() {
        // Return the path to node.gpgtoml if found
        return Some(node_gpgtoml);
    }

    // Neither file was found in the directory
    None
}
// // Usage example for your specific case:
// let current_full_file_path = PathBuf::from("/your/actual/path");

// // Call the function to find either node.toml or node.gpgtoml
// let node_toml_path = match find_node_toml_or_gpgtoml_file(&current_full_file_path) {
//     Some(path) => {
//         // Successfully found one of the configuration files
//         debug_log!(
//             "nav_graph_look_read_node_toml() node_toml_path -> {:?}",
//             path.clone()
//         );

//         // Add more detailed existence checking
//         debug_log!("Checking if path exists: {:?}", path.exists());
//         debug_log!("Checking if path is file: {:?}", path.is_file());

//         // Return the found path
//         path
//     },
//     None => {
//         // Neither node.toml nor node.gpgtoml was found
//         debug_log!(
//             "nav_graph_look_read_node_toml() no configuration file found in: {:?}",
//             current_full_file_path
//         );

//         // Handle the error case - you need to decide what to do here
//         // Option 1: Return an error from your function
//         return Err("No node configuration file found".to_string());

//         // Option 2: Use a default or panic (not recommended)
//         // panic!("No node configuration file found");
//     }
// };

// // At this point, node_toml_path contains the PathBuf to whichever file was found

    // --- Stage 3: Walk Through Team Channels ---
    // for entry in WalkDir::new(&team_channels_dir) // ⚠️ This recursively walks ALL subdirectories!
    //     .into_iter()
    //     .filter_map(|e| e.ok())
    //     .filter(|e| e.file_type().is_dir())
    // {
